/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include "rpcrig.h"
/*
 *  Hamlib Interface - RPC definitions
 *  Copyright (c) 2000,2001 by Stephane Fillod and Frank Singleton
 *
 *		$Id: rpcrig_xdr.c,v 1.3 2001-12-27 21:58:47 fillods Exp $
 *
 *   This library is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU Library General Public License as
 *   published by the Free Software Foundation; either version 2 of
 *   the License, or (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU Library General Public License for more details.
 *
 *   You should have received a copy of the GNU Library General Public
 *   License along with this library; if not, write to the Free Software
 *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 */

bool_t
xdr_model_x (XDR *xdrs, model_x *objp)
{
	register int32_t *buf;

	 if (!xdr_u_int (xdrs, objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_vfo_x (XDR *xdrs, vfo_x *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_freq_x (XDR *xdrs, freq_x *objp)
{
	register int32_t *buf;

	 if (!xdr_int64_t (xdrs, objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_rmode_x (XDR *xdrs, rmode_x *objp)
{
	register int32_t *buf;

	 if (!xdr_u_int (xdrs, objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_pbwidth_x (XDR *xdrs, pbwidth_x *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_split_x (XDR *xdrs, split_x *objp)
{
	register int32_t *buf;

	 if (!xdr_u_long (xdrs, objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ptt_x (XDR *xdrs, ptt_x *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dcd_x (XDR *xdrs, dcd_x *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_vfo_op_x (XDR *xdrs, vfo_op_x *objp)
{
	register int32_t *buf;

	 if (!xdr_long (xdrs, objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_shortfreq_x (XDR *xdrs, shortfreq_x *objp)
{
	register int32_t *buf;

	 if (!xdr_long (xdrs, objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_setting_x (XDR *xdrs, setting_x *objp)
{
	register int32_t *buf;

	 if (!xdr_uint64_t (xdrs, objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ant_x (XDR *xdrs, ant_x *objp)
{
	register int32_t *buf;

	 if (!xdr_long (xdrs, objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ann_x (XDR *xdrs, ann_x *objp)
{
	register int32_t *buf;

	 if (!xdr_long (xdrs, objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_mode_s (XDR *xdrs, mode_s *objp)
{
	register int32_t *buf;

	 if (!xdr_rmode_x (xdrs, &objp->mode))
		 return FALSE;
	 if (!xdr_pbwidth_x (xdrs, &objp->width))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_value_s (XDR *xdrs, value_s *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->i))
		 return FALSE;
	 if (!xdr_float (xdrs, &objp->f))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_freq_arg (XDR *xdrs, freq_arg *objp)
{
	register int32_t *buf;

	 if (!xdr_vfo_x (xdrs, &objp->vfo))
		 return FALSE;
	 if (!xdr_freq_x (xdrs, &objp->freq))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_freq_res (XDR *xdrs, freq_res *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->rigstatus))
		 return FALSE;
	switch (objp->rigstatus) {
	case 0:
		 if (!xdr_freq_x (xdrs, &objp->freq_res_u.freq))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_mode_arg (XDR *xdrs, mode_arg *objp)
{
	register int32_t *buf;

	 if (!xdr_vfo_x (xdrs, &objp->vfo))
		 return FALSE;
	 if (!xdr_mode_s (xdrs, &objp->mw))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_mode_res (XDR *xdrs, mode_res *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->rigstatus))
		 return FALSE;
	switch (objp->rigstatus) {
	case 0:
		 if (!xdr_mode_s (xdrs, &objp->mode_res_u.mw))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_vfo_res (XDR *xdrs, vfo_res *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->rigstatus))
		 return FALSE;
	switch (objp->rigstatus) {
	case 0:
		 if (!xdr_vfo_x (xdrs, &objp->vfo_res_u.vfo))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_split_arg (XDR *xdrs, split_arg *objp)
{
	register int32_t *buf;

	 if (!xdr_vfo_x (xdrs, &objp->vfo))
		 return FALSE;
	 if (!xdr_split_x (xdrs, &objp->split))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_split_res (XDR *xdrs, split_res *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->rigstatus))
		 return FALSE;
	switch (objp->rigstatus) {
	case 0:
		 if (!xdr_split_x (xdrs, &objp->split_res_u.split))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_ptt_arg (XDR *xdrs, ptt_arg *objp)
{
	register int32_t *buf;

	 if (!xdr_vfo_x (xdrs, &objp->vfo))
		 return FALSE;
	 if (!xdr_ptt_x (xdrs, &objp->ptt))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_ptt_res (XDR *xdrs, ptt_res *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->rigstatus))
		 return FALSE;
	switch (objp->rigstatus) {
	case 0:
		 if (!xdr_ptt_x (xdrs, &objp->ptt_res_u.ptt))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_dcd_res (XDR *xdrs, dcd_res *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->rigstatus))
		 return FALSE;
	switch (objp->rigstatus) {
	case 0:
		 if (!xdr_dcd_x (xdrs, &objp->dcd_res_u.dcd))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_setting_arg (XDR *xdrs, setting_arg *objp)
{
	register int32_t *buf;

	 if (!xdr_vfo_x (xdrs, &objp->vfo))
		 return FALSE;
	 if (!xdr_setting_x (xdrs, &objp->setting))
		 return FALSE;
	 if (!xdr_value_s (xdrs, &objp->val))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_val_res (XDR *xdrs, val_res *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->rigstatus))
		 return FALSE;
	switch (objp->rigstatus) {
	case 0:
		 if (!xdr_value_s (xdrs, &objp->val_res_u.val))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_vfo_op_arg (XDR *xdrs, vfo_op_arg *objp)
{
	register int32_t *buf;

	 if (!xdr_vfo_x (xdrs, &objp->vfo))
		 return FALSE;
	 if (!xdr_vfo_op_x (xdrs, &objp->op))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_freq_range_s (XDR *xdrs, freq_range_s *objp)
{
	register int32_t *buf;

	 if (!xdr_freq_x (xdrs, &objp->start))
		 return FALSE;
	 if (!xdr_freq_x (xdrs, &objp->end))
		 return FALSE;
	 if (!xdr_rmode_x (xdrs, &objp->modes))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->low_power))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->high_power))
		 return FALSE;
	 if (!xdr_vfo_x (xdrs, &objp->vfo))
		 return FALSE;
	 if (!xdr_ant_x (xdrs, &objp->ant))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_tuning_step_s (XDR *xdrs, tuning_step_s *objp)
{
	register int32_t *buf;

	 if (!xdr_rmode_x (xdrs, &objp->modes))
		 return FALSE;
	 if (!xdr_shortfreq_x (xdrs, &objp->ts))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_filter_s (XDR *xdrs, filter_s *objp)
{
	register int32_t *buf;

	 if (!xdr_rmode_x (xdrs, &objp->modes))
		 return FALSE;
	 if (!xdr_pbwidth_x (xdrs, &objp->width))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_chan_s (XDR *xdrs, chan_s *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->start))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->end))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->type))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_rigstate_s (XDR *xdrs, rigstate_s *objp)
{
	register int32_t *buf;

	int i;

	if (xdrs->x_op == XDR_ENCODE) {
		 if (!xdr_int (xdrs, &objp->itu_region))
			 return FALSE;
		 if (!xdr_shortfreq_x (xdrs, &objp->max_rit))
			 return FALSE;
		 if (!xdr_shortfreq_x (xdrs, &objp->max_xit))
			 return FALSE;
		 if (!xdr_shortfreq_x (xdrs, &objp->max_ifshift))
			 return FALSE;
		 if (!xdr_ann_x (xdrs, &objp->announces))
			 return FALSE;
		 if (!xdr_setting_x (xdrs, &objp->has_get_func))
			 return FALSE;
		 if (!xdr_setting_x (xdrs, &objp->has_set_func))
			 return FALSE;
		 if (!xdr_setting_x (xdrs, &objp->has_get_level))
			 return FALSE;
		 if (!xdr_setting_x (xdrs, &objp->has_set_level))
			 return FALSE;
		 if (!xdr_setting_x (xdrs, &objp->has_get_parm))
			 return FALSE;
		 if (!xdr_setting_x (xdrs, &objp->has_set_parm))
			 return FALSE;
		buf = XDR_INLINE (xdrs, ( MAXDBLSTSIZ  + MAXDBLSTSIZ ) * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_vector (xdrs, (char *)objp->preamp, MAXDBLSTSIZ,
				sizeof (int), (xdrproc_t) xdr_int))
				 return FALSE;
			 if (!xdr_vector (xdrs, (char *)objp->attenuator, MAXDBLSTSIZ,
				sizeof (int), (xdrproc_t) xdr_int))
				 return FALSE;

		} else {
		{
			register int *genp;

			for (i = 0, genp = objp->preamp;
				i < MAXDBLSTSIZ; ++i) {
				IXDR_PUT_LONG(buf, *genp++);
			}
		}
		{
			register int *genp;

			for (i = 0, genp = objp->attenuator;
				i < MAXDBLSTSIZ; ++i) {
				IXDR_PUT_LONG(buf, *genp++);
			}
		}
		}
		 if (!xdr_vector (xdrs, (char *)objp->rx_range_list, FRQRANGESIZ,
			sizeof (freq_range_s), (xdrproc_t) xdr_freq_range_s))
			 return FALSE;
		 if (!xdr_vector (xdrs, (char *)objp->tx_range_list, FRQRANGESIZ,
			sizeof (freq_range_s), (xdrproc_t) xdr_freq_range_s))
			 return FALSE;
		 if (!xdr_vector (xdrs, (char *)objp->tuning_steps, TSLSTSIZ,
			sizeof (tuning_step_s), (xdrproc_t) xdr_tuning_step_s))
			 return FALSE;
		 if (!xdr_vector (xdrs, (char *)objp->filters, FLTLSTSIZ,
			sizeof (filter_s), (xdrproc_t) xdr_filter_s))
			 return FALSE;
		 if (!xdr_vector (xdrs, (char *)objp->chan_list, CHANLSTSIZ,
			sizeof (chan_s), (xdrproc_t) xdr_chan_s))
			 return FALSE;
		return TRUE;
	} else if (xdrs->x_op == XDR_DECODE) {
		 if (!xdr_int (xdrs, &objp->itu_region))
			 return FALSE;
		 if (!xdr_shortfreq_x (xdrs, &objp->max_rit))
			 return FALSE;
		 if (!xdr_shortfreq_x (xdrs, &objp->max_xit))
			 return FALSE;
		 if (!xdr_shortfreq_x (xdrs, &objp->max_ifshift))
			 return FALSE;
		 if (!xdr_ann_x (xdrs, &objp->announces))
			 return FALSE;
		 if (!xdr_setting_x (xdrs, &objp->has_get_func))
			 return FALSE;
		 if (!xdr_setting_x (xdrs, &objp->has_set_func))
			 return FALSE;
		 if (!xdr_setting_x (xdrs, &objp->has_get_level))
			 return FALSE;
		 if (!xdr_setting_x (xdrs, &objp->has_set_level))
			 return FALSE;
		 if (!xdr_setting_x (xdrs, &objp->has_get_parm))
			 return FALSE;
		 if (!xdr_setting_x (xdrs, &objp->has_set_parm))
			 return FALSE;
		buf = XDR_INLINE (xdrs, ( MAXDBLSTSIZ  + MAXDBLSTSIZ ) * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_vector (xdrs, (char *)objp->preamp, MAXDBLSTSIZ,
				sizeof (int), (xdrproc_t) xdr_int))
				 return FALSE;
			 if (!xdr_vector (xdrs, (char *)objp->attenuator, MAXDBLSTSIZ,
				sizeof (int), (xdrproc_t) xdr_int))
				 return FALSE;

		} else {
		{
			register int *genp;

			for (i = 0, genp = objp->preamp;
				i < MAXDBLSTSIZ; ++i) {
				*genp++ = IXDR_GET_LONG(buf);
			}
		}
		{
			register int *genp;

			for (i = 0, genp = objp->attenuator;
				i < MAXDBLSTSIZ; ++i) {
				*genp++ = IXDR_GET_LONG(buf);
			}
		}
		}
		 if (!xdr_vector (xdrs, (char *)objp->rx_range_list, FRQRANGESIZ,
			sizeof (freq_range_s), (xdrproc_t) xdr_freq_range_s))
			 return FALSE;
		 if (!xdr_vector (xdrs, (char *)objp->tx_range_list, FRQRANGESIZ,
			sizeof (freq_range_s), (xdrproc_t) xdr_freq_range_s))
			 return FALSE;
		 if (!xdr_vector (xdrs, (char *)objp->tuning_steps, TSLSTSIZ,
			sizeof (tuning_step_s), (xdrproc_t) xdr_tuning_step_s))
			 return FALSE;
		 if (!xdr_vector (xdrs, (char *)objp->filters, FLTLSTSIZ,
			sizeof (filter_s), (xdrproc_t) xdr_filter_s))
			 return FALSE;
		 if (!xdr_vector (xdrs, (char *)objp->chan_list, CHANLSTSIZ,
			sizeof (chan_s), (xdrproc_t) xdr_chan_s))
			 return FALSE;
	 return TRUE;
	}

	 if (!xdr_int (xdrs, &objp->itu_region))
		 return FALSE;
	 if (!xdr_shortfreq_x (xdrs, &objp->max_rit))
		 return FALSE;
	 if (!xdr_shortfreq_x (xdrs, &objp->max_xit))
		 return FALSE;
	 if (!xdr_shortfreq_x (xdrs, &objp->max_ifshift))
		 return FALSE;
	 if (!xdr_ann_x (xdrs, &objp->announces))
		 return FALSE;
	 if (!xdr_setting_x (xdrs, &objp->has_get_func))
		 return FALSE;
	 if (!xdr_setting_x (xdrs, &objp->has_set_func))
		 return FALSE;
	 if (!xdr_setting_x (xdrs, &objp->has_get_level))
		 return FALSE;
	 if (!xdr_setting_x (xdrs, &objp->has_set_level))
		 return FALSE;
	 if (!xdr_setting_x (xdrs, &objp->has_get_parm))
		 return FALSE;
	 if (!xdr_setting_x (xdrs, &objp->has_set_parm))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->preamp, MAXDBLSTSIZ,
		sizeof (int), (xdrproc_t) xdr_int))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->attenuator, MAXDBLSTSIZ,
		sizeof (int), (xdrproc_t) xdr_int))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->rx_range_list, FRQRANGESIZ,
		sizeof (freq_range_s), (xdrproc_t) xdr_freq_range_s))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->tx_range_list, FRQRANGESIZ,
		sizeof (freq_range_s), (xdrproc_t) xdr_freq_range_s))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->tuning_steps, TSLSTSIZ,
		sizeof (tuning_step_s), (xdrproc_t) xdr_tuning_step_s))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->filters, FLTLSTSIZ,
		sizeof (filter_s), (xdrproc_t) xdr_filter_s))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->chan_list, CHANLSTSIZ,
		sizeof (chan_s), (xdrproc_t) xdr_chan_s))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_rigstate_res (XDR *xdrs, rigstate_res *objp)
{
	register int32_t *buf;

	 if (!xdr_int (xdrs, &objp->rigstatus))
		 return FALSE;
	switch (objp->rigstatus) {
	case 0:
		 if (!xdr_rigstate_s (xdrs, &objp->rigstate_res_u.state))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}
